export default "import { Jwt, PresentationExchange } from '@web5/credentials';\n// :prepend-end:\nimport { DidJwk } from '@web5/dids';\n// :prepend-start: knownCustomerCredentialResolveIssuerDidJS\nimport { resolveDid } from '@tbdex/protocol'\n// :prepend-end:\n\nconst issuerBearerDid = await DidJwk.create();\nconst issuerDidUri = issuerBearerDid.uri;\nconst customerBearerDid = await DidJwk.create();\n\ndescribe('Presentation Exchange Process', () => {\n  const nameCredentialJwt =\n    'eyJ0eXAiOiJKV1QiLCJhbGciOiJFZERTQSIsImtpZCI6ImRpZDpkaHQ6ZmM2cjZiZzY5dDZrOHU5dTlzdTUzYWFmNmp1MXhkcHdkenV3M2tqdThzc2FtYjNwcHN1byMwIn0.eyJ2YyI6eyJAY29udGV4dCI6WyJodHRwczovL3d3dy53My5vcmcvMjAxOC9jcmVkZW50aWFscy92MSJdLCJ0eXBlIjpbIlZlcmlmaWFibGVDcmVkZW50aWFsIiwiSURDYXJkQ3JlZGVudGlhbFBhcnQxIl0sImlkIjoidXJuOnV1aWQ6NTdhNWU4ZWUtYmZlMC00YjQwLWJmMDAtZTA4MTY5ZDk5Y2Q1IiwiaXNzdWVyIjoiZGlkOmRodDpmYzZyNmJnNjl0Nms4dTl1OXN1NTNhYWY2anUxeGRwd2R6dXcza2p1OHNzYW1iM3Bwc3VvIiwiaXNzdWFuY2VEYXRlIjoiMjAyNC0wMy0yMVQyMToyMTo1MVoiLCJjcmVkZW50aWFsU3ViamVjdCI6eyJpZCI6ImRpZDpkaHQ6ejU0Z3U0NnU5Y2VxYjQ4dzM0dGVvNGdxMzR3Z2FvNHJvNzVjd3VyZTk1YWNlNXNpOGR0byIsImdpdmVuX25hbWUiOiJBbGljZSIsImZhbWlseV9uYW1lIjoiU21pdGgifX0sImlzcyI6ImRpZDpkaHQ6ZmM2cjZiZzY5dDZrOHU5dTlzdTUzYWFmNmp1MXhkcHdkenV3M2tqdThzc2FtYjNwcHN1byIsInN1YiI6ImRpZDpkaHQ6ejU0Z3U0NnU5Y2VxYjQ4dzM0dGVvNGdxMzR3Z2FvNHJvNzVjd3VyZTk1YWNlNXNpOGR0byJ9.kt0rKEgZ1_U4eTUNDgUU9LzmFViHsx_1z6llfFAqCdpzwIsKKYbqfbtgckJDsoV9xqgG5TYAVPxeLo5hCAguDA';\n  const idCredentialJwt =\n    'eyJ0eXAiOiJKV1QiLCJhbGciOiJFZERTQSIsImtpZCI6ImRpZDpkaHQ6ZmM2cjZiZzY5dDZrOHU5dTlzdTUzYWFmNmp1MXhkcHdkenV3M2tqdThzc2FtYjNwcHN1byMwIn0.eyJ2YyI6eyJAY29udGV4dCI6WyJodHRwczovL3d3dy53My5vcmcvMjAxOC9jcmVkZW50aWFscy92MSJdLCJ0eXBlIjpbIlZlcmlmaWFibGVDcmVkZW50aWFsIiwiSURDYXJkQ3JlZGVudGlhbFBhcnQyIl0sImlkIjoidXJuOnV1aWQ6YTM5ZmQ3NjgtNjVjMy00MDZhLWIwMGItMTg1MjIxM2ExYzhjIiwiaXNzdWVyIjoiZGlkOmRodDpmYzZyNmJnNjl0Nms4dTl1OXN1NTNhYWY2anUxeGRwd2R6dXcza2p1OHNzYW1iM3Bwc3VvIiwiaXNzdWFuY2VEYXRlIjoiMjAyNC0wMy0yMVQyMToyMTo1MVoiLCJjcmVkZW50aWFsU3ViamVjdCI6eyJpZCI6ImRpZDpkaHQ6ejU0Z3U0NnU5Y2VxYjQ4dzM0dGVvNGdxMzR3Z2FvNHJvNzVjd3VyZTk1YWNlNXNpOGR0byIsImJpcnRoZGF0ZSI6IjE5OTAtMDEtMDEiLCJuYXRpb25hbF9pZGVudGlmaWVyIjoiMTIzLTQ1LTY3ODkifX0sImlzcyI6ImRpZDpkaHQ6ZmM2cjZiZzY5dDZrOHU5dTlzdTUzYWFmNmp1MXhkcHdkenV3M2tqdThzc2FtYjNwcHN1byIsInN1YiI6ImRpZDpkaHQ6ejU0Z3U0NnU5Y2VxYjQ4dzM0dGVvNGdxMzR3Z2FvNHJvNzVjd3VyZTk1YWNlNXNpOGR0byJ9.lQOBdE3LGQ_rLz69SQoI_auOsFpsOESBIbHNf9HpYTGYTT2aYw8WrKd1rXQuRqzgELcv92iWQRpWoVm193x3CQ';\n  const credentials = [nameCredentialJwt, idCredentialJwt];\n  const presentation_definition = {\n    id: 'IDCardCredentials',\n    input_descriptors: [\n      // Given Name Verification\n      {\n        id: 'givenNameVerification',\n        purpose: 'We need to verify your given name.',\n        constraints: {\n          fields: [\n            {\n              path: [\n                '$.credentialSubject.given_name',\n                '$.vc.credentialSubject.given_name',\n              ],\n              filter: {\n                type: 'string',\n              },\n            },\n          ],\n        },\n      },\n      // Family Name Verification\n      {\n        id: 'familyNameVerification',\n        purpose: 'We need to verify your family name.',\n        constraints: {\n          fields: [\n            {\n              path: [\n                '$.credentialSubject.family_name',\n                '$.vc.credentialSubject.family_name',\n              ],\n              filter: {\n                type: 'string',\n              },\n            },\n          ],\n        },\n      },\n      // Birthdate Verification\n      {\n        id: 'birthdateVerification',\n        purpose: 'We need to verify your birthdate.',\n        constraints: {\n          fields: [\n            {\n              path: [\n                '$.credentialSubject.birthdate',\n                '$.vc.credentialSubject.birthdate',\n              ],\n              filter: {\n                type: 'string',\n                format: 'date',\n              },\n            },\n          ],\n        },\n      },\n      // National Identifier Verification\n      {\n        id: 'nationalIdentifierVerification',\n        purpose: 'We need to verify your national identifier.',\n        constraints: {\n          fields: [\n            {\n              path: [\n                '$.credentialSubject.national_identifier',\n                '$.vc.credentialSubject.national_identifier',\n              ],\n              filter: {\n                type: 'string',\n              },\n            },\n          ],\n        },\n      },\n    ],\n  };\n\n  test('presentation exchange selects, satisfies and creates VP', async () => {\n    const allCredentials = credentials;\n    const selectedCredentials = PresentationExchange.selectCredentials({\n      vcJwts: allCredentials,\n      presentationDefinition: presentation_definition,\n    });\n\n    PresentationExchange.satisfiesPresentationDefinition({\n      vcJwts: selectedCredentials,\n      presentationDefinition: presentation_definition,\n    });\n\n    const vp = PresentationExchange.createPresentationFromCredentials({\n      vcJwts: selectedCredentials,\n      presentationDefinition: presentation_definition,\n    });\n\n    expect(selectedCredentials).toBeDefined();\n    expect(selectedCredentials).toBeInstanceOf(Array);\n    expect.soft(selectedCredentials.length).toBe(2);\n    expect(vp).toBeDefined();\n    expect(vp).toHaveProperty('presentation');\n    expect(vp.presentation).toHaveProperty('presentation_submission');\n    expect(vp.presentation).toHaveProperty('verifiableCredential');\n    expect(vp.presentation.type).toContain('VerifiablePresentation');\n  });\n\n  test('Jwt.sign() works with a bearer DID & valid payload', async () => {\n    const accessTokenPayload = {\n      sub: customerBearerDid.uri,\n      iss: issuerBearerDid.uri,\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + 86400,\n    };\n    const accessToken = await Jwt.sign({\n      signerDid: issuerBearerDid,\n      payload: accessTokenPayload,\n    });\n\n    expect(typeof accessToken).toBe('string');\n    expect(accessToken).not.toBe('');\n  });\n});\n\n// :snippet-start: knownCustomerCredentialResolveIssuerDidJS\nasync function resolveIssuerDid(issuerDidUri) {\n  try {\n    /****************************************\n     * Resolve DID & Get IDV Service Endpoint\n     ****************************************/\n    const didDocument = await resolveDid(issuerDidUri)\n    const idvService = didDocument.service.find(\n      (service) => service.type === 'IDV',\n    );\n\n    if (idvService) {\n      return idvService.serviceEndpoint;\n    } else {\n      throw new Error('IDV service not found in DID Document');\n    }\n  } catch (error) {\n    throw new Error(`Error resolving DID: ${error.message}`);\n  }\n}\n\nasync function handleSiopRequest(encodedSiopRequest) {\n  /*************************************************************\n   * Decode the SIOP request JAR from the encoded URL parameters\n   *************************************************************/\n  const params = new URLSearchParams(encodedSiopRequest);\n  const jwtRequest = params.get('request');\n\n  if (!jwtRequest) {\n    throw new Error('No JWT found in SIOP Request');\n  }\n\n  let decodedSiopRequest;\n  try {\n    decodedSiopRequest = await Jwt.verify({ jwt: jwtRequest });\n  } catch (error) {\n    throw new Error(`Error decoding SIOP Request JWT: ${error.message}`);\n  }\n\n  // Extract the payload from the verified JWT\n  const siopRequest = decodedSiopRequest.payload.request;\n\n  /*******************************************************\n   * Generate & sign id_token\n   *******************************************************/\n  const idTokenPayload = {\n    iss: customerBearerDid.uri, // user's DID string\n    sub: customerBearerDid.uri,\n    aud: siopRequest.client_id,\n    nonce: siopRequest.nonce,\n    exp: Math.floor(Date.now() / 1000) + 60 * 60, // Expiration time\n    iat: Math.floor(Date.now() / 1000), // Issued at time\n  };\n\n  const idToken = await Jwt.sign({\n    signerDid: customerBearerDid,\n    payload: idTokenPayload,\n  });\n\n  let vpToken;\n  if (siopRequest.response_type.includes('vp_token')) {\n    try {\n      /*******************************************************\n       * Select Credentials based on the Presentation Definition\n       *******************************************************/\n      const selectedCredentials = await PresentationExchange.selectCredentials({\n        vcJwts: userVcJwts, // Array of VC JWTs stored in the user's Wallet\n        presentationDefinition: siopRequest.presentation_definition,\n      });\n\n      PresentationExchange.satisfiesPresentationDefinition({\n        vcJwts: selectedCredentials,\n        presentationDefinition: siopRequest.presentation_definition,\n      });\n\n      /*******************************************************\n       * Generate & sign vp_token\n       *******************************************************/\n      const vp = await PresentationExchange.createPresentationFromCredentials({\n        vcJwts: selectedCredentials,\n        presentationDefinition: siopRequest.presentation_definition,\n      });\n\n      vpToken = await Jwt.sign({ signerDid: customerBearerDid, payload: vp });\n    } catch (error) {\n      throw new Error(\n        `Presentation Definition not satisfied: ${error.message}`,\n      );\n    }\n  }\n  /*******************************************************\n   * POST SIOPv2 Authorization response to the response_uri\n   *******************************************************/\n  const responsePayload = {\n    id_token: idToken,\n    ...(vpToken && { vp_token: vpToken }),\n  };\n\n  fetch(siopRequest.response_uri, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(responsePayload),\n  })\n    .then((response) => response.json())\n    .then((data) => {\n      handleIssuerResponse(data); // function shown in next step\n    })\n    .catch((error) => {\n      throw new Error(`Error sending SIOP response: ${error.message}`);\n    });\n}\n";