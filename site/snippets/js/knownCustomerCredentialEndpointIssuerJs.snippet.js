export default "app.post('/credentials', async (req, res) => {\n  try {\n    /*****************************************************************\n     * Extract and validate the access token from Authorization header\n     ******************************************************************/\n    const authHeader = req.headers['authorization'];\n    if (!authHeader) {\n      return res\n        .status(401)\n        .json({ errors: ['Authorization header required'] });\n    }\n\n    const tokenParts = authHeader.split('Bearer ');\n    if (tokenParts.length !== 2) {\n      return res\n        .status(401)\n        .json({ errors: ['Authorization header format is Bearer <token>'] });\n    }\n\n    const accessToken = tokenParts[1];\n    const storedCNonce = accessTokenToCNonceMap.get(accessToken);\n    if (!storedCNonce) {\n      return res\n        .status(401)\n        .json({ errors: ['Invalid or expired access token'] });\n    }\n\n    /**************************************************************\n     * Extract and validate the JWT and nonce from the proof object\n     **************************************************************/\n    const { proof } = req.body;\n    if (!proof || proof.proof_type !== 'jwt' || !proof.jwt) {\n      return res.status(400).json({ errors: ['Invalid proof provided'] });\n    }\n\n    let customersDidUri, payload;\n\n    try {\n      const verificationResult = await Jwt.verify({ jwt: proof.jwt });\n      customersDidUri = verificationResult.payload.iss; // Customer's Decentralized Identifier string\n      if (storedCNonce === payload.nonce) {\n        accessTokenToCNonceMap.delete(accessToken);\n      } else {\n        return res.status(401).json({ errors: ['Invalid nonce in proof'] });\n      }\n    } catch (error) {\n      return res.status(401).json({ errors: ['Invalid JWT in proof'] });\n    }\n\n    /***********************************************\n     * Create and sign the credential\n     ************************************************/\n    const kccCredentialInstance = new KccCredential('US', 'Gold', {\n      country: \"US\" \n      },\n      {\n        id: \"https://vc.schemas.host/kcc.schema.json\",\n        type: \"JsonSchema\"\n      },\n      [\n        {\n          kind: 'document_verification',\n          checks: ['passport', 'utility_bill'],\n        },\n        {\n          kind: 'sanction_screening',\n          checks: ['PEP'],\n        },\n      ]\n    );\n\n    const known_customer_credential = await VerifiableCredential.create({\n      issuer: issuerBearerDid.uri, // Issuer's Decentralized Identifier string\n      subject: customersDidUri, // Customer's Decentralized Identifier string from the verified JWT\n      expirationDate: '2026-05-19T08:02:04Z',\n      data: {\n        countryOfResidence: kccCredentialInstance.data.countryOfResidence,\n        tier: kccCredentialInstance.data.tier, // optional\n        jurisdiction: kccCredentialInstance.data.jurisdiction // optional\n      },\n      credentialSchema: kccCredentialInstance.credentialSchema,\n      evidence: kccCredentialInstance.evidence, // optional\n    });\n\n    const credential_token = await known_customer_credential.sign({\n      did: issuerBearerDid, // Signing with the issuer's bearer DID\n    });\n    /***********************************************\n     * Respond with the signed credential\n     ************************************************/\n    return res.status(200).json({ credential: credential_token });\n  } catch (error) {\n    /***********************************************\n     * Generic error handling\n     ************************************************/\n    return res.status(500).json({\n      errors: [`An unexpected error occurred: ${error.message}`],\n    });\n  }\n});\n";