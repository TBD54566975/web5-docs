export default "post(\"/credentials\") {\n    try {\n        /*****************************************************************\n        * Extract and validate the access token from Authorization header\n        ******************************************************************/\n        val authHeader = call.request.headers[\"Authorization\"]\n        if (authHeader.isNullOrEmpty()) {\n            call.respond(HttpStatusCode.Unauthorized, mapOf(\n                \"errors\" to listOf(\"Authorization header required\")\n            ))\n            return@post\n        }\n\n        val tokenParts = authHeader.split(\"Bearer \")\n        if (tokenParts.size != 2) {\n            call.respond(HttpStatusCode.Unauthorized, mapOf(\n                \"errors\" to listOf(\"Authorization header format is Bearer <token>\")\n            ))\n            return@post\n        }\n\n        val accessToken = tokenParts[1]\n        val storedCNonce = accessTokenToCNonceMap[accessToken]\n        if (storedCNonce == null) {\n            call.respond(HttpStatusCode.Unauthorized, mapOf(\n                \"errors\" to listOf(\"Invalid or expired access token\")\n            ))\n            return@post\n        }\n\n        /********************************************************\n        * Extract and validate the JWT from the proof object\n        *********************************************************/\n        val requestBody = call.receive<JsonObject>()\n        val proof = requestBody[\"proof\"]?.jsonObject\n        val proofJwt = proof?.get(\"jwt\")?.jsonPrimitive?.content\n\n        if (proof == null || \n        proof[\"proof_type\"]?.jsonPrimitive?.content != \"jwt\" || \n        proofJwt.isNullOrEmpty()\n        ) {\n            call.respond(HttpStatusCode.BadRequest, mapOf(\"errors\" to listOf(\"Invalid proof provided\")))\n            return@post\n        }\n\n        VerifiableCredential.verify(proofJwt)\n        val claimsSet = JWTParser.parse(proofJwt).jwtClaimsSet\n        val customersDidUri = claimsSet.subject ?: \"\"\n        val nonceInProof = claimsSet.getStringClaim(\"nonce\")\n\n        /***********************************************\n        * Validate the signed c_nonce\n        ************************************************/\n        if (storedCNonce == nonceInProof) {\n            accessTokenToCNonceMap.remove(accessToken) \n        } else {\n            call.respond(HttpStatusCode.Unauthorized, mapOf(\"errors\" to listOf(\"Invalid nonce in proof\")))\n            return@post\n        }\n\n        /***********************************************\n        * Create and sign the credential\n        ************************************************/\n        val evidence = listOf(\n            Evidence(\n                kind = \"document_verification\",\n                checks = listOf(\"passport\", \"utility_bill\")\n            ),\n            Evidence(\n                kind = \"sanction_screening\",\n                checks = listOf(\"PEP\")\n            )\n        )\n        val dateFormat = SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\")\n        val expirationDate: Date = dateFormat.parse(\"2026-05-19T08:02:04Z\")\n\n        val knownCustomerCredential = VerifiableCredential.create(\n            type = \"VerifiableCredential\",\n            issuer = issuerBearerDid.uri, // Issuer's DID string\n            subject = customersDidUri, // Customer's DID string from the verified JWT\n            expirationDate = expirationDate,\n            evidence = evidence,\n            data = KccCredential(countryOfResidence = \"US\", tier = \"Gold\", jurisdiction = \"US\"),\n            credentialSchema = CredentialSchema(\n                id = \"https://vc.schemas.host/kcc.schema.json\",\n                type = \"JsonSchema\"\n            ),\n        )\n\n        val credentialToken = knownCustomerCredential.sign(\n            issuerBearerDid // Signing with the issuer's bearer DID\n        ) \n\n        /***********************************************\n        * Respond with the signed credential\n        ************************************************/\n        call.respond(HttpStatusCode.OK, mapOf(\"credential\" to credentialToken))\n    } catch (error: Exception) {\n        /***********************************************\n        * Generic error handling\n        ************************************************/\n        call.respond(HttpStatusCode.InternalServerError, mapOf(\n            \"errors\" to listOf(\"An unexpected error occurred: ${error.message}\")\n        ))\n    }\n}\n";