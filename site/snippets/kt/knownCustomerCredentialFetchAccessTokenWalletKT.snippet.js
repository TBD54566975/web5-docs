export default "private suspend fun fetchAccessToken(preAuthorizationCode: String?, tokenEndpoint: String?, retryDelay: Long = 10000L) {\n    val client = HttpClient()\n\n    val requestBody = buildJsonObject {\n        put(\"grant_type\", \"urn:ietf:params:oauth:grant-type:pre-authorized_code\")\n        put(\"code\", preAuthorizationCode)\n        put(\"client_id\", userBearerDid.uri) // user's DID string\n    }\n\n    try {\n        val httpResponse: HttpResponse = client.post(tokenEndpoint ?: \n        throw IllegalArgumentException(\"tokenEndpoint cannot be null\")\n        ) {\n            contentType(ContentType.Application.Json)\n            setBody(requestBody.toString())\n        }\n\n        if (!httpResponse.status.isSuccess()) {\n            throw Exception(\"HTTP error! Status: ${httpResponse.status}\")\n        }\n\n        val responseText: String = httpResponse.bodyAsText()\n        val json = Json.parseToJsonElement(responseText).jsonObject\n\n        /*******************************************\n        * Handle the \"authorization_pending\" error\n        ********************************************/\n        json[\"error\"]?.jsonPrimitive?.content?.let { error ->\n            if (error == \"authorization_pending\") {\n                displayNotification(\"Hang tight, we're still waiting for IDV to complete.\")\n                delay(retryDelay)\n\n                return fetchAccessToken(preAuthorizationCode, tokenEndpoint, retryDelay)\n            } else {\n                throw Exception(\"Error from server: $error\")\n            }\n        } ?: run {\n        /*************************************************\n        * Store the access token & c_nonce for future use\n        **************************************************/\n            WalletStorage.accessToken = json[\"access_token\"]?.jsonPrimitive?.content\n            WalletStorage.cNonce = json[\"c_nonce\"]?.jsonPrimitive?.content\n            WalletStorage.credentialEndpoint?.let { credentialEndpoint ->\n                WalletStorage.accessToken?.let { accessToken ->\n                    requestKnownCustomerCredential(\n                        credentialEndpoint, \n                        accessToken) // function shown in next step\n                }\n            }\n\n        }\n    } catch (e: Exception) {\n        println(\"Error fetching access token: ${e.message}\")\n    } finally {\n        client.close()\n    }\n}\n";